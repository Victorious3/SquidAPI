/*******************************************************************************
 * Copyright (c) 2015 CoolSquid.
 * All rights reserved.
 *******************************************************************************/
package coolsquid.squidapi;

import java.util.List;
import java.util.Set;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import coolsquid.squidapi.command.CommandDisable;
import coolsquid.squidapi.exception.IncompatibilityException;
import coolsquid.squidapi.exception.JarZipError;
import coolsquid.squidapi.exception.MisuseException;
import coolsquid.squidapi.helpers.ExceptionHelper;
import coolsquid.squidapi.logging.ILogger;
import coolsquid.squidapi.mod.BaseMod;
import coolsquid.squidapi.mod.SideOnly.ClientOnly;
import coolsquid.squidapi.mod.SideOnly.ServerOnly;
import coolsquid.squidapi.util.Incompatibility;
import coolsquid.squidapi.util.Incompatibility.Severity;
import coolsquid.squidapi.util.MiscLib;
import coolsquid.squidapi.util.ModManager;
import coolsquid.squidapi.util.StringUtils;
import coolsquid.squidapi.util.Utils;
import coolsquid.squidapi.util.math.IntUtils;
import coolsquid.squidapi.util.math.Timer;
import coolsquid.squidapi.util.objects.Suggestion;
import coolsquid.squidapi.util.version.Updateable;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.ModMetadata;

public class SquidAPIMod extends BaseMod implements Updateable, ILogger {

	private final Set<Incompatibility> incompatibilities = Sets.newHashSet();
	private final int hashCode;
	protected final Logger logger;
	protected final ExceptionHelper exceptionHelper;
	protected final Timer timer;

	public SquidAPIMod() {
		this(null);
	}

	public SquidAPIMod(int curseId) {
		this(null, curseId);
	}

	public SquidAPIMod(String desc) {
		this(desc, null);
	}

	public SquidAPIMod(String desc, int curseId) {
		this(desc, null, curseId);
	}

	public SquidAPIMod(String desc, String url) {
		this(desc, url, null);
	}

	public SquidAPIMod(String desc, String url, int curseId) {
		this(desc, url, null, curseId);
	}

	public SquidAPIMod(String desc, String url, String updateUrl) {
		this(desc, null, url, updateUrl);
	}

	public SquidAPIMod(String desc, String url, String updateUrl, int curseId) {
		this(desc, null, url, updateUrl, curseId);
	}

	public SquidAPIMod(String desc, String credits, String url, String updateUrl) {
		this(desc, null, credits, url, updateUrl);
	}

	public SquidAPIMod(String desc, String credits, String url, String updateUrl, int curseId) {
		this(desc, null, credits, url, updateUrl, curseId);
	}

	public SquidAPIMod(String desc, List<String> authors, String credits, String url, String updateUrl, int curseId) {
		this(desc, authors, credits, url, updateUrl);
		Utils.runVersionCheckerCompat(curseId);
	}

	public SquidAPIMod(String desc, List<String> authors, String credits, String url, String updateUrl) {
		super(Loader.instance().activeModContainer());

		final byte prime = 31;
		int result = 1;
		result = prime * result + this.getModid().hashCode();
		result = prime * result + this.getVersion().hashCode();
		this.hashCode = result;

		this.logger = LogManager.getLogger(this.getName());
		this.exceptionHelper = ExceptionHelper.getInstance(this);
		this.timer = new Timer();

		ModMetadata meta = this.mod.getMetadata();
		meta.autogenerated = false;
		meta.credits = credits != null ? credits : "";
		meta.authorList = authors != null ? authors : Lists.newArrayList("CoolSquid");
		meta.description = desc != null ? desc : "";
		meta.url = url != null ? url : "http://coolsquidmc.blogspot.no/";
		meta.updateUrl = updateUrl != null ? updateUrl : "";

		if (this instanceof ClientOnly && MiscLib.SERVER) {
			throw new MisuseException(this.getName() + " is clientside only!");
		}
		else if (this instanceof ServerOnly && MiscLib.CLIENT) {
			throw new MisuseException(this.getName() + " is serverside only!");
		}

		if (this instanceof Disableable) {
			CommandDisable.disableables.put(this.getModid(), (Disableable) this);
		}

		if (!MiscLib.DEV_ENVIRONMENT && !this.getSource().getName().endsWith(".jar")) {
			String marker = "========================================================================================";
			this.error(marker);
			this.error("SquidAPI has detected that the " + this.getName() + " mod file is named " + this.getSource().getName() + '.');
			this.error("As the filename is not ending in .jar, certain hooks were not loaded by FML.");
			this.error("Please rename the file to SquidAPI-" + this.getVersion() + ".jar.");
			this.error(marker);
			throw new JarZipError(this.getName() + " cannot be loaded as a zip file");
		}

		ModManager.INSTANCE.registerMod(this);
	}

	public int getVersionId() {
		return IntUtils.parseInt(this.getVersion());
	}

	public final Set<Incompatibility> getIncompatibilities() {
		return ImmutableSet.copyOf(this.incompatibilities);
	}

	protected final void registerIncompatibility(Incompatibility incompatibility) {
		if (Loader.isModLoaded(incompatibility.getModid())) {
			if (incompatibility.getSeverity().isFatal()) {
				throw new IncompatibilityException(incompatibility, this.getName());
			}
			this.incompatibilities.add(incompatibility);
		}
	}

	protected final void registerIncompatibility(String modid, String reason, Severity severity) {
		this.registerIncompatibility(new Incompatibility(modid, reason, severity));
	}

	@Deprecated
	protected final void suggestMod(Suggestion suggestion) {

	}

	@Deprecated
	protected final void suggestMod(String suggestion, String reason, String url) {

	}

	@Deprecated
	protected final void suggestMod(String suggestion, String modid, String reason, String url) {

	}

	@Deprecated
	protected final void setDisableable() {
		if (!(this instanceof Disableable)) {
			throw new IllegalArgumentException();
		}
		CommandDisable.disableables.put(this.getModid(), (Disableable) this);
	}

	protected final void preInit() {

	}

	protected final void init() {

	}

	protected final void postInit() {
		for (Incompatibility a: this.getIncompatibilities()) {
			this.bigWarning("Incompatibility detected! " + this.mod.getName() + " has issues with " + a.getModid() + ". Reason: " + a.getReason() + " Severity: " + a.getSeverity() + '.' + MiscLib.LINE + "Please contact " + this.mod.getMetadata().getAuthorList() + " for more information.");
		}
	}

	public long hash() {
		return this.hashCode;
	}

	@Override
	public boolean equals(Object obj) {
		return this.hashCode() == obj.hashCode();
	}

	@Override
	public String toString() {
		return "SquidAPIMod [modid=" + this.getModid() + ", version=" + this.getVersion() + "]";
	}

	@Override
	public int hashCode() {
		return this.hashCode;
	}

	protected void setUpdateUrl(String url) {
		this.getMetadata().updateUrl = url;
	}

	@Override
	public String getUrl() {
		return this.getMetadata().updateUrl.isEmpty() ? null : this.getMetadata().updateUrl;
	}

	public Timer getTimer() {
		return this.timer;
	}

	public Logger getLogger() {
		return this.logger;
	}

	private void log(Level level, Object[] msg) {
		for (Object object: msg) {
			this.log(level, object.toString());
		}
	}

	private void log(Level level, String msg) {
		this.logger.log(level, msg);
		MiscLib.LOGGER.log(this.getName(), level, msg);
	}

	@Override
	public void info(Object[] msg) {
		this.log(Level.INFO, msg);
	}

	@Override
	public void debug(Object[] msg) {
		this.log(Level.DEBUG, msg);
	}

	@Override
	public void warn(Object[] msg) {
		this.log(Level.WARN, msg);
	}

	@Override
	public void error(Object[] msg) {
		this.log(Level.ERROR, msg);
	}

	@Override
	public void fatal(Object[] msg) {
		this.log(Level.FATAL, msg);
	}

	@Override
	public void info(String msg) {
		this.log(Level.INFO, msg);
	}

	@Override
	public void debug(String msg) {
		this.log(Level.DEBUG, msg);
	}

	@Override
	public void warn(String msg) {
		this.log(Level.WARN, msg);
	}

	@Override
	public void error(String msg) {
		this.log(Level.ERROR, msg);
	}

	@Override
	public void fatal(String msg) {
		this.log(Level.FATAL, msg);
	}

	public void bigWarning(String msg) {
		String b = StringUtils.repeat('=', msg.length());
		this.log(Level.FATAL, b);
		for (String c: msg.split(MiscLib.LINE)) {
			this.log(Level.FATAL, c);
		}
		this.log(Level.FATAL, b);
	}

	public ExceptionHelper getExceptionHelper() {
		return this.exceptionHelper;
	}

	@Override
	public void info(Throwable t) {
		this.exceptionHelper.log(Level.INFO, t);
	}

	@Override
	public void debug(Throwable t) {
		this.exceptionHelper.log(Level.DEBUG, t);
	}

	@Override
	public void warn(Throwable t) {
		this.exceptionHelper.log(Level.WARN, t);
	}

	@Override
	public void error(Throwable t) {
		this.exceptionHelper.log(Level.ERROR, t);
	}

	@Override
	public void fatal(Throwable t) {
		this.exceptionHelper.log(Level.FATAL, t);
	}

	@Override
	public void info(Iterable<?> msg) {
		for (Object object: msg) {
			this.info(object.toString());
		}
	}

	@Override
	public void debug(Iterable<?> msg) {
		for (Object object: msg) {
			this.debug(object.toString());
		}
	}

	@Override
	public void warn(Iterable<?> msg) {
		for (Object object: msg) {
			this.warn(object.toString());
		}
	}

	@Override
	public void error(Iterable<?> msg) {
		for (Object object: msg) {
			this.error(object.toString());
		}
	}

	@Override
	public void fatal(Iterable<?> msg) {
		for (Object object: msg) {
			this.fatal(object.toString());
		}
	}

	@Override
	public void info(Object msg) {
		this.info(msg.toString());
	}

	@Override
	public void debug(Object msg) {
		this.debug(msg.toString());
	}

	@Override
	public void warn(Object msg) {
		this.warn(msg.toString());
	}

	@Override
	public void error(Object msg) {
		this.error(msg.toString());
	}

	@Override
	public void fatal(Object msg) {
		this.fatal(msg.toString());
	}
}